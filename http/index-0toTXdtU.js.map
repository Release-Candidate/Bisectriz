{"version":3,"file":"index-0toTXdtU.js","sources":["../index.html?html-proxy&index=0.js","../node_modules/solid-js/dist/solid.js","../node_modules/solid-js/web/dist/web.js","../src/zodiacs.ts","../src/ZodiacAngleInput.tsx","../src/circle.tsx","../src/ZodiacAnglesDisplay.tsx","../src/App.tsx","../src/index.tsx"],"sourcesContent":["\n            if (\"serviceWorker\" in navigator) {\n                navigator.serviceWorker\n                    .register(new URL(\"./sw.js\", import.meta.url), {\n                        type: \"module\",\n                        scope: PWA_SERVER_PATH,\n                    })\n                    .then(function () {\n                        console.log(\"[index.html] Service Worker Registered\");\n                    });\n            }\n        ","let taskIdCounter = 1,\n  isCallbackScheduled = false,\n  isPerformingWork = false,\n  taskQueue = [],\n  currentTask = null,\n  shouldYieldToHost = null,\n  yieldInterval = 5,\n  deadline = 0,\n  maxYieldInterval = 300,\n  scheduleCallback = null,\n  scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n    port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = (n + m) >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;\n      else if (cmp < 0) n = k - 1;\n      else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n    timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {\n  context: undefined,\n  registry: undefined\n};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return {\n    ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    current = detachedOwner === undefined ? owner : detachedOwner,\n    root = unowned\n      ? UNOWNED\n      : {\n          owned: null,\n          cleanups: null,\n          context: current ? current.context : null,\n          owner: current\n        },\n    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);\n      else value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  if (!options || !options.render) c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(\n      () => {\n        fn ? fn() : untrack(onInvalidate);\n        fn = undefined;\n      },\n      undefined,\n      false,\n      0\n    ),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction isPromise(v) {\n  return v && typeof v === \"object\" && \"then\" in v;\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if ((arguments.length === 2 && typeof pFetcher === \"object\") || arguments.length === 1) {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  } else {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  }\n  let pr = null,\n    initP = NO_INIT,\n    id = null,\n    loadedUnderTransition = false,\n    scheduled = false,\n    resolved = \"initialValue\" in options,\n    dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = new Set(),\n    [value, setValue] = (options.storage || createSignal)(options.initialValue),\n    [error, setError] = createSignal(undefined),\n    [track, trigger] = createSignal(undefined, {\n      equals: false\n    }),\n    [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    let v;\n    if (options.ssrLoadFrom === \"initial\") initP = options.initialValue;\n    else if (sharedConfig.load && (v = sharedConfig.load(id))) initP = v;\n  }\n  function loadEnd(p, v, error, key) {\n    if (pr === p) {\n      pr = null;\n      key !== undefined && (resolved = true);\n      if ((p === initP || v === initP) && options.onHydrated)\n        queueMicrotask(() =>\n          options.onHydrated(key, {\n            value: v\n          })\n        );\n      initP = NO_INIT;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          completeLoad(v, error);\n        }, false);\n      } else completeLoad(v, error);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === undefined) setValue(() => v);\n      setState(err !== undefined ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c = SuspenseContext && useContext(SuspenseContext),\n      v = value(),\n      err = error();\n    if (err !== undefined && !pr) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);\n          else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p =\n      initP !== NO_INIT\n        ? initP\n        : untrack(() =>\n            fetcher(lookup, {\n              value: value(),\n              refetching\n            })\n          );\n    if (!isPromise(p)) {\n      loadEnd(pr, p, undefined, lookup);\n      return p;\n    }\n    pr = p;\n    if (\"value\" in p) {\n      if (p.status === \"success\") loadEnd(pr, p.value, undefined, lookup);\n      else loadEnd(pr, undefined, undefined, lookup);\n      return p;\n    }\n    scheduled = true;\n    queueMicrotask(() => (scheduled = false));\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p.then(\n      v => loadEnd(p, v, undefined, lookup),\n      e => loadEnd(p, undefined, castError(e), lookup)\n    );\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s = state();\n        return s === \"pending\" || s === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));\n  else load(false);\n  return [\n    read,\n    {\n      refetch: load,\n      mutate: setValue\n    }\n  ];\n}\nfunction createDeferred(source, options) {\n  let t,\n    timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(\n    () => {\n      if (!t || !t.fn)\n        t = requestCallback(\n          () => setDeferred(() => node.value),\n          timeout !== undefined\n            ? {\n                timeout\n              }\n            : undefined\n        );\n      return source();\n    },\n    undefined,\n    true\n  );\n  const [deferred, setDeferred] = createSignal(\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    options\n  );\n  updateComputation(node);\n  setDeferred(() =>\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n  );\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(\n    p => {\n      const v = source();\n      for (const [key, val] of subs.entries())\n        if (fn(key, v) !== fn(key, p)) {\n          for (const c of val.values()) {\n            c.state = STALE;\n            if (c.pure) Updates.push(c);\n            else Effects.push(c);\n          }\n        }\n      return v;\n    },\n    undefined,\n    true,\n    STALE\n  );\n  updateComputation(node);\n  return key => {\n    const listener = Listener;\n    if (listener) {\n      let l;\n      if ((l = subs.get(key))) l.add(listener);\n      else subs.set(key, (l = new Set([listener])));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(\n      key,\n      Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n    );\n  };\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (!ExternalSourceConfig && Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return prevValue;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null);\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction catchError(fn, handler) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  Owner = createComputation(undefined, undefined, true);\n  Owner.context = {\n    ...Owner.context,\n    [ERROR]: [handler]\n  };\n  if (Transition && Transition.running) Transition.sources.add(Owner);\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = Owner.owner;\n  }\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t =\n        Transition ||\n        (Transition = {\n          sources: new Set(),\n          effects: [],\n          promises: new Set(),\n          disposed: new Set(),\n          queue: new Set(),\n          running: true\n        });\n      t.done || (t.done = new Promise(res => (t.resolve = res)));\n      t.running = true;\n    }\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nconst [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  return Owner && Owner.context && Owner.context[context.id] !== undefined\n    ? Owner.context[context.id]\n    : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext());\n}\nfunction enableExternalSource(factory, untrack = fn => fn()) {\n  if (ExternalSourceConfig) {\n    const { factory: oldFactory, untrack: oldUntrack } = ExternalSourceConfig;\n    ExternalSourceConfig = {\n      factory: (fn, trigger) => {\n        const oldSource = oldFactory(fn, trigger);\n        const source = factory(x => oldSource.track(x), trigger);\n        return {\n          track: x => source.track(x),\n          dispose() {\n            source.dispose();\n            oldSource.dispose();\n          }\n        };\n      },\n      untrack: fn => oldUntrack(() => untrack(fn))\n    };\n  } else {\n    ExternalSourceConfig = {\n      factory,\n      untrack\n    };\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (runningTransition ? this.tState : this.state)) {\n    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current =\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    if (Transition) {\n      const TransitionRunning = Transition.running;\n      if (TransitionRunning || (!isComp && Transition.sources.has(node))) {\n        Transition.sources.add(node);\n        node.tValue = value;\n      }\n      if (!TransitionRunning) node.value = value;\n    } else node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) continue;\n          if (TransitionRunning ? !o.tState : !o.state) {\n            if (o.pure) Updates.push(o);\n            else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (!TransitionRunning) o.state = STALE;\n          else o.tState = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (false);\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(\n    node,\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    time\n  );\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        Listener = Owner = node;\n        runComputation(node, node.tValue, time);\n        Listener = Owner = null;\n      }, false);\n    });\n  }\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner,\n    listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      if (Transition && Transition.running) {\n        node.tState = STALE;\n        node.tOwned && node.tOwned.forEach(cleanNode);\n        node.tOwned = undefined;\n      } else {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null);\n  else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];\n      else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];\n      else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceConfig && c.fn) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if ((runningTransition ? node.tState : node.state) === 0) return;\n  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (runningTransition ? node.tState : node.state) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n        prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if ((runningTransition ? node.tState : node.state) === STALE) {\n      updateComputation(node);\n    } else if ((runningTransition ? node.tState : node.state) === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);\n    else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition) {\n    if (!Transition.promises.size && !Transition.queue.size) {\n      const sources = Transition.sources;\n      const disposed = Transition.disposed;\n      Effects.push.apply(Effects, Transition.effects);\n      res = Transition.resolve;\n      for (const e of Effects) {\n        \"tState\" in e && (e.state = e.tState);\n        delete e.tState;\n      }\n      Transition = null;\n      runUpdates(() => {\n        for (const d of disposed) cleanNode(d);\n        for (const v of sources) {\n          v.value = v.tValue;\n          if (v.owned) {\n            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n          }\n          if (v.tOwned) v.owned = v.tOwned;\n          delete v.tValue;\n          delete v.tOwned;\n          v.tState = 0;\n        }\n        setTransPending(false);\n      }, false);\n    } else if (Transition.running) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n  }\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);\n    else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) {\n    if (sharedConfig.count) {\n      sharedConfig.effects || (sharedConfig.effects = []);\n      sharedConfig.effects.push(...queue.slice(0, userLength));\n      return;\n    } else if (sharedConfig.effects) {\n      queue = [...sharedConfig.effects, ...queue];\n      userLength += sharedConfig.effects.length;\n      delete sharedConfig.effects;\n    }\n    setHydrateContext();\n  }\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;\n  else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      const state = runningTransition ? source.tState : source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))\n          runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (runningTransition ? !o.tState : !o.state) {\n      if (runningTransition) o.tState = PENDING;\n      else o.state = PENDING;\n      if (o.pure) Updates.push(o);\n      else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;\n  else node.state = 0;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction runErrors(err, fns, owner) {\n  try {\n    for (const f of fns) f(err);\n  } catch (e) {\n    handleError(e, (owner && owner.owner) || null);\n  }\n}\nfunction handleError(err, owner = Owner) {\n  const fns = ERROR && owner && owner.context && owner.context[ERROR];\n  const error = castError(err);\n  if (!fns) throw error;\n  if (Effects)\n    Effects.push({\n      fn() {\n        runErrors(error, fns, owner);\n      },\n      state: STALE\n    });\n  else runErrors(error, fns, owner);\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(\n      () =>\n        (res = untrack(() => {\n          Owner.context = {\n            ...Owner.context,\n            [id]: props.value\n          };\n          return children(() => props.children);\n        })),\n      undefined\n    );\n    return res;\n  };\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null);\n  else if (Owner.context === null || !Owner.context[ERROR]) {\n    Owner.context = {\n      ...Owner.context,\n      [ERROR]: [fn]\n    };\n    mutateContext(Owner, ERROR, [fn]);\n  } else Owner.context[ERROR].push(fn);\n}\nfunction mutateContext(o, key, value) {\n  if (o.owned) {\n    for (let i = 0; i < o.owned.length; i++) {\n      if (o.owned[i].context === o.context) mutateContext(o.owned[i], key, value);\n      if (!o.owned[i].context) {\n        o.owned[i].context = o.context;\n        mutateContext(o.owned[i], key, value);\n      } else if (!o.owned[i].context[key]) {\n        o.owned[i].context[key] = value;\n        mutateContext(o.owned[i], key, value);\n      }\n    }\n  }\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler =\n        typeof observer === \"function\" ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createEffect(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => (\"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub()));\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n        newIndices,\n        newIndicesNext,\n        temp,\n        tempdisposers,\n        tempIndexes,\n        start,\n        end,\n        newEnd,\n        item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (\n          start = 0, end = Math.min(len, newLen);\n          start < end && items[start] === newItems[start];\n          start++\n        );\n        for (\n          end = len - 1, newEnd = newLen - 1;\n          end >= start && newEnd >= start && items[end] === newItems[newEnd];\n          end--, newEnd--\n        ) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, (len = newLen));\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return (mapped = mapped.slice(0, len));\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction resolveSources() {\n  for (let i = 0, length = this.length; i < length; ++i) {\n    const v = this[i]();\n    if (v !== undefined) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || (!!s && $PROXY in s);\n    sources[i] = typeof s === \"function\" ? ((proxy = true), createMemo(s)) : s;\n  }\n  if (proxy) {\n    return new Proxy(\n      {\n        get(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            const v = resolveSource(sources[i])[property];\n            if (v !== undefined) return v;\n          }\n        },\n        has(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            if (property in resolveSource(sources[i])) return true;\n          }\n          return false;\n        },\n        keys() {\n          const keys = [];\n          for (let i = 0; i < sources.length; i++)\n            keys.push(...Object.keys(resolveSource(sources[i])));\n          return [...new Set(keys)];\n        }\n      },\n      propTraps\n    );\n  }\n  const sourcesMap = {};\n  const defined = Object.create(null);\n  for (let i = sources.length - 1; i >= 0; i--) {\n    const source = sources[i];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i = sourceKeys.length - 1; i >= 0; i--) {\n      const key = sourceKeys[i];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get\n          ? {\n              enumerable: true,\n              configurable: true,\n              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))\n            }\n          : desc.value !== undefined\n          ? desc\n          : undefined;\n      } else {\n        const sources = sourcesMap[key];\n        if (sources) {\n          if (desc.get) sources.push(desc.get.bind(source));\n          else if (desc.value !== undefined) sources.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i = definedKeys.length - 1; i >= 0; i--) {\n    const key = definedKeys[i],\n      desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : undefined;\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if ($PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map(k => {\n      return new Proxy(\n        {\n          get(property) {\n            return k.includes(property) ? props[property] : undefined;\n          },\n          has(property) {\n            return k.includes(property) && property in props;\n          },\n          keys() {\n            return k.filter(property => property in props);\n          }\n        },\n        propTraps\n      );\n    });\n    res.push(\n      new Proxy(\n        {\n          get(property) {\n            return blocked.has(property) ? undefined : props[property];\n          },\n          has(property) {\n            return blocked.has(property) ? false : property in props;\n          },\n          keys() {\n            return Object.keys(props).filter(k => !blocked.has(k));\n          }\n        },\n        propTraps\n      )\n    );\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc =\n      !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc\n          ? (objects[objectIndex][propName] = desc.value)\n          : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc\n        ? (otherObject[propName] = desc.value)\n        : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      sharedConfig.count || (sharedConfig.count = 0);\n      sharedConfig.count++;\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        sharedConfig.count--;\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    }\n    let Comp;\n    return createMemo(\n      () =>\n        (Comp = comp()) &&\n        untrack(() => {\n          if (false);\n          if (!ctx) return Comp(props);\n          const c = sharedConfig.context;\n          setHydrateContext(ctx);\n          const r = Comp(props);\n          setHydrateContext(c);\n          return r;\n        })\n    );\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => (comp = () => mod.default)), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nconst narrowedError = name => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => (keyed ? a === b : !a === !b)\n  });\n  return createMemo(\n    () => {\n      const c = condition();\n      if (c) {\n        const child = props.children;\n        const fn = typeof child === \"function\" && child.length > 0;\n        return fn\n          ? untrack(() =>\n              child(\n                keyed\n                  ? c\n                  : () => {\n                      if (!untrack(condition)) throw narrowedError(\"Show\");\n                      return props.when;\n                    }\n              )\n            )\n          : child;\n      }\n      return props.fallback;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Switch(props) {\n  let keyed = false;\n  const equals = (a, b) => (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];\n  const conditions = children(() => props.children),\n    evalConditions = createMemo(\n      () => {\n        let conds = conditions();\n        if (!Array.isArray(conds)) conds = [conds];\n        for (let i = 0; i < conds.length; i++) {\n          const c = conds[i].when;\n          if (c) {\n            keyed = !!conds[i].keyed;\n            return [i, c, conds[i]];\n          }\n        }\n        return [-1];\n      },\n      undefined,\n      {\n        equals\n      }\n    );\n  return createMemo(\n    () => {\n      const [index, when, cond] = evalConditions();\n      if (index < 0) return props.fallback;\n      const c = cond.children;\n      const fn = typeof c === \"function\" && c.length > 0;\n      return fn\n        ? untrack(() =>\n            c(\n              keyed\n                ? when\n                : () => {\n                    if (untrack(evalConditions)[0] !== index) throw narrowedError(\"Match\");\n                    return cond.when;\n                  }\n            )\n          )\n        : c;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err;\n  if (sharedConfig.context && sharedConfig.load)\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count);\n  const [errored, setErrored] = createSignal(err, undefined);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(\n    () => {\n      let e;\n      if ((e = errored())) {\n        const f = props.fallback;\n        return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored())) : f;\n      }\n      return catchError(() => props.children, setErrored);\n    },\n    undefined,\n    undefined\n  );\n}\n\nconst suspenseListEquals = (a, b) =>\n  a.showContent === b.showContent && a.showFallback === b.showFallback;\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let [wrapper, setWrapper] = createSignal(() => ({\n      inFallback: false\n    })),\n    show;\n  const listContext = useContext(SuspenseListContext);\n  const [registry, setRegistry] = createSignal([]);\n  if (listContext) {\n    show = listContext.register(createMemo(() => wrapper()().inFallback));\n  }\n  const resolved = createMemo(\n    prev => {\n      const reveal = props.revealOrder,\n        tail = props.tail,\n        { showContent = true, showFallback = true } = show ? show() : {},\n        reg = registry(),\n        reverse = reveal === \"backwards\";\n      if (reveal === \"together\") {\n        const all = reg.every(inFallback => !inFallback());\n        const res = reg.map(() => ({\n          showContent: all && showContent,\n          showFallback\n        }));\n        res.inFallback = !all;\n        return res;\n      }\n      let stop = false;\n      let inFallback = prev.inFallback;\n      const res = [];\n      for (let i = 0, len = reg.length; i < len; i++) {\n        const n = reverse ? len - i - 1 : i,\n          s = reg[n]();\n        if (!stop && !s) {\n          res[n] = {\n            showContent,\n            showFallback\n          };\n        } else {\n          const next = !stop;\n          if (next) inFallback = true;\n          res[n] = {\n            showContent: next,\n            showFallback: !tail || (next && tail === \"collapsed\") ? showFallback : false\n          };\n          stop = true;\n        }\n      }\n      if (!stop) inFallback = false;\n      res.inFallback = inFallback;\n      return res;\n    },\n    {\n      inFallback: false\n    }\n  );\n  setWrapper(() => resolved);\n  return createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        let index;\n        setRegistry(registry => {\n          index = registry.length;\n          return [...registry, inFallback];\n        });\n        return createMemo(() => resolved()[index], undefined, {\n          equals: suspenseListEquals\n        });\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction Suspense(props) {\n  let counter = 0,\n    show,\n    ctx,\n    p,\n    flicker,\n    error;\n  const [inFallback, setFallback] = createSignal(false),\n    SuspenseContext = getSuspenseContext(),\n    store = {\n      increment: () => {\n        if (++counter === 1) setFallback(true);\n      },\n      decrement: () => {\n        if (--counter === 0) setFallback(false);\n      },\n      inFallback,\n      effects: [],\n      resolved: false\n    },\n    owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    let ref = sharedConfig.load(key);\n    if (ref) {\n      if (typeof ref !== \"object\" || ref.status !== \"success\") p = ref;\n      else sharedConfig.gather(key);\n    }\n    if (p && p !== \"$$f\") {\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(\n        () => {\n          if (sharedConfig.done) return set();\n          sharedConfig.gather(key);\n          setHydrateContext(ctx);\n          set();\n          setHydrateContext();\n        },\n        err => {\n          error = err;\n          set();\n        }\n      );\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) show = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return (flicker = undefined);\n        }\n        if (ctx && p === \"$$f\") setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(prev => {\n          const inFallback = store.inFallback(),\n            { showContent = true, showFallback = true } = show ? show() : {};\n          if ((!inFallback || (p && p !== \"$$f\")) && showContent) {\n            store.resolved = true;\n            dispose && dispose();\n            dispose = ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!showFallback) return;\n          if (dispose) return prev;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nconst DEV = undefined;\n\nexport {\n  $DEVCOMP,\n  $PROXY,\n  $TRACK,\n  DEV,\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  Show,\n  Suspense,\n  SuspenseList,\n  Switch,\n  batch,\n  cancelCallback,\n  catchError,\n  children,\n  createComponent,\n  createComputed,\n  createContext,\n  createDeferred,\n  createEffect,\n  createMemo,\n  createReaction,\n  createRenderEffect,\n  createResource,\n  createRoot,\n  createSelector,\n  createSignal,\n  createUniqueId,\n  enableExternalSource,\n  enableHydration,\n  enableScheduling,\n  equalFn,\n  from,\n  getListener,\n  getOwner,\n  indexArray,\n  lazy,\n  mapArray,\n  mergeProps,\n  observable,\n  on,\n  onCleanup,\n  onError,\n  onMount,\n  requestCallback,\n  resetErrorBoundaries,\n  runWithOwner,\n  sharedConfig,\n  splitProps,\n  startTransition,\n  untrack,\n  useContext,\n  useTransition\n};\n","import {\n  createRoot,\n  sharedConfig,\n  createRenderEffect,\n  untrack,\n  enableHydration,\n  getOwner,\n  createEffect,\n  runWithOwner,\n  createMemo,\n  createSignal,\n  onCleanup,\n  splitProps\n} from \"solid-js\";\nexport {\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  Show,\n  Suspense,\n  SuspenseList,\n  Switch,\n  createComponent,\n  createRenderEffect as effect,\n  getOwner,\n  createMemo as memo,\n  mergeProps,\n  untrack\n} from \"solid-js\";\n\nconst booleans = [\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"indeterminate\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"seamless\",\n  \"selected\"\n];\nconst Properties = /*#__PURE__*/ new Set([\n  \"className\",\n  \"value\",\n  \"readOnly\",\n  \"formNoValidate\",\n  \"isMap\",\n  \"noModule\",\n  \"playsInline\",\n  ...booleans\n]);\nconst ChildProperties = /*#__PURE__*/ new Set([\n  \"innerHTML\",\n  \"textContent\",\n  \"innerText\",\n  \"children\"\n]);\nconst Aliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  class: \"className\",\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a = PropAliases[prop];\n  return typeof a === \"object\" ? (a[tagName] ? a[\"$\"] : undefined) : a;\n}\nconst DelegatedEvents = /*#__PURE__*/ new Set([\n  \"beforeinput\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"focusin\",\n  \"focusout\",\n  \"input\",\n  \"keydown\",\n  \"keyup\",\n  \"mousedown\",\n  \"mousemove\",\n  \"mouseout\",\n  \"mouseover\",\n  \"mouseup\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerout\",\n  \"pointerover\",\n  \"pointerup\",\n  \"touchend\",\n  \"touchmove\",\n  \"touchstart\"\n]);\nconst SVGElements = /*#__PURE__*/ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/ new Set([\n  \"html\",\n  \"base\",\n  \"head\",\n  \"link\",\n  \"meta\",\n  \"style\",\n  \"title\",\n  \"body\",\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"footer\",\n  \"header\",\n  \"main\",\n  \"nav\",\n  \"section\",\n  \"body\",\n  \"blockquote\",\n  \"dd\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"figcaption\",\n  \"figure\",\n  \"hr\",\n  \"li\",\n  \"ol\",\n  \"p\",\n  \"pre\",\n  \"ul\",\n  \"a\",\n  \"abbr\",\n  \"b\",\n  \"bdi\",\n  \"bdo\",\n  \"br\",\n  \"cite\",\n  \"code\",\n  \"data\",\n  \"dfn\",\n  \"em\",\n  \"i\",\n  \"kbd\",\n  \"mark\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"small\",\n  \"span\",\n  \"strong\",\n  \"sub\",\n  \"sup\",\n  \"time\",\n  \"u\",\n  \"var\",\n  \"wbr\",\n  \"area\",\n  \"audio\",\n  \"img\",\n  \"map\",\n  \"track\",\n  \"video\",\n  \"embed\",\n  \"iframe\",\n  \"object\",\n  \"param\",\n  \"picture\",\n  \"portal\",\n  \"source\",\n  \"svg\",\n  \"math\",\n  \"canvas\",\n  \"noscript\",\n  \"script\",\n  \"del\",\n  \"ins\",\n  \"caption\",\n  \"col\",\n  \"colgroup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"tr\",\n  \"button\",\n  \"datalist\",\n  \"fieldset\",\n  \"form\",\n  \"input\",\n  \"label\",\n  \"legend\",\n  \"meter\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"progress\",\n  \"select\",\n  \"textarea\",\n  \"details\",\n  \"dialog\",\n  \"menu\",\n  \"summary\",\n  \"details\",\n  \"slot\",\n  \"template\",\n  \"acronym\",\n  \"applet\",\n  \"basefont\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"center\",\n  \"content\",\n  \"dir\",\n  \"font\",\n  \"frame\",\n  \"frameset\",\n  \"hgroup\",\n  \"image\",\n  \"keygen\",\n  \"marquee\",\n  \"menuitem\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"plaintext\",\n  \"rb\",\n  \"rtc\",\n  \"shadow\",\n  \"spacer\",\n  \"strike\",\n  \"tt\",\n  \"xmp\",\n  \"a\",\n  \"abbr\",\n  \"acronym\",\n  \"address\",\n  \"applet\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"basefont\",\n  \"bdi\",\n  \"bdo\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"center\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"content\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"dir\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"font\",\n  \"footer\",\n  \"form\",\n  \"frame\",\n  \"frameset\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"image\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"marquee\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"plaintext\",\n  \"portal\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"shadow\",\n  \"slot\",\n  \"small\",\n  \"source\",\n  \"spacer\",\n  \"span\",\n  \"strike\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"tt\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n  \"xmp\",\n  \"input\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\"\n]);\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n    aEnd = a.length,\n    bEnd = bLength,\n    aStart = 0,\n    bStart = 0,\n    after = a[aEnd - 1].nextSibling,\n    map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? (bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart]) : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n            sequence = 1,\n            t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document\n      ? code()\n      : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, isCE, isSVG) {\n  let node;\n  const create = () => {\n    const t = document.createElement(\"template\");\n    t.innerHTML = html;\n    return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;\n  };\n  const fn = isCE\n    ? () => untrack(() => document.importNode(node || (node = create()), true))\n    : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setProperty(node, name, value) {\n  if (!!sharedConfig.context && node.isConnected) return;\n  node[name] = value;\n}\nfunction setAttribute(node, name, value) {\n  if (!!sharedConfig.context && node.isConnected) return;\n  if (value == null) node.removeAttribute(name);\n  else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (!!sharedConfig.context && node.isConnected) return;\n  if (value == null) node.removeAttributeNS(namespace, name);\n  else node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (!!sharedConfig.context && node.isConnected) return;\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, (handler[0] = e => handlerFn.call(node, handler[1], e)));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n    prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n      classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return (nodeStyle.cssText = value);\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  if (!skipChildren) {\n    createRenderEffect(\n      () => (prevProps.children = insertExpression(node, props.children, prevProps.children))\n    );\n  }\n  createRenderEffect(() =>\n    typeof props.ref === \"function\" ? use(props.ref, node) : (props.ref = node)\n  );\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = id => globalThis._$HY.r[id];\n  sharedConfig.has = id => id in globalThis._$HY.r;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes], options);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get((key = getHydrationKey())))) {\n    return template();\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n    count = 0,\n    current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"$\") count++;\n        else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const { completed, events } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)\n    node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev);\n    value && node.addEventListener(e, value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if (\n    (forceProp = prop.slice(0, 5) === \"prop:\") ||\n    (isChildProp = ChildProperties.has(prop)) ||\n    (!isSVG &&\n      ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop)))) ||\n    (isCE = node.nodeName.includes(\"-\"))\n  ) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    } else if (!!sharedConfig.context && node.isConnected) return value;\n    if (prop === \"class\" || prop === \"className\") className(node, value);\n    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;\n    else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);\n    else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = (e.composedPath && e.composedPath()[0]) || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;\n  while (node) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node = node._$host || node.parentNode || node.host;\n  }\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  const hydrating = !!sharedConfig.context && parent.isConnected;\n  if (hydrating) {\n    !current && (current = [...parent.childNodes]);\n    let cleaned = [];\n    for (let i = 0; i < current.length; i++) {\n      const node = current[i];\n      if (node.nodeType === 8 && node.data.slice(0, 2) === \"!$\") node.remove();\n      else cleaned.push(node);\n    }\n    current = cleaned;\n  }\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n    multi = marker !== undefined;\n  parent = (multi && current[0] && current[0].parentNode) || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (hydrating) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (hydrating) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => (current = insertExpression(parent, array, current, marker, true)));\n      return () => current;\n    }\n    if (hydrating) {\n      if (!array.length) return current;\n      if (marker === undefined) return [...parent.childNodes];\n      let node = array[0];\n      let nodes = [node];\n      while ((node = node.nextSibling) !== marker) nodes.push(node);\n      return (current = nodes);\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (hydrating && value.parentNode) return (current = multi ? [value] : value);\n    if (Array.isArray(current)) {\n      if (multi) return (current = cleanChildren(parent, current, marker, value));\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n      prev = current && current[normalized.length],\n      t;\n    if (item == null || item === true || item === false);\n    else if ((t = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic =\n          normalizeIncomingArray(\n            normalized,\n            Array.isArray(item) ? item : [item],\n            Array.isArray(prev) ? prev : [prev]\n          ) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return (parent.textContent = \"\");\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i)\n          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key))\n      sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\nfunction Hydration(props) {\n  return props.children;\n}\nconst voidFn = () => undefined;\nconst RequestContext = Symbol();\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction ssrElement(name, props, children, needsId) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrAttribute(key, value) {}\nfunction ssrHydrationKey() {}\nfunction resolveSSRNode(node) {}\nfunction escape(html) {}\nfunction ssrSpread(props, isSVG, skipChildren) {}\n\nconst isServer = false;\nconst isDev = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const { useShadow } = props,\n    marker = document.createTextNode(\"\"),\n    mount = () => props.mount || document.body,\n    owner = getOwner();\n  let content;\n  let hydrating = !!sharedConfig.context;\n  createEffect(\n    () => {\n      if (hydrating) getOwner().user = hydrating = false;\n      content || (content = runWithOwner(owner, () => createMemo(() => props.children)));\n      const el = mount();\n      if (el instanceof HTMLHeadElement) {\n        const [clean, setClean] = createSignal(false);\n        const cleanup = () => setClean(true);\n        createRoot(dispose => insert(el, () => (!clean() ? content() : dispose()), null));\n        onCleanup(cleanup);\n      } else {\n        const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot =\n            useShadow && container.attachShadow\n              ? container.attachShadow({\n                  mode: \"open\"\n                })\n              : container;\n        Object.defineProperty(container, \"_$host\", {\n          get() {\n            return marker.parentNode;\n          },\n          configurable: true\n        });\n        insert(renderRoot, content);\n        el.appendChild(container);\n        props.ref && props.ref(container);\n        onCleanup(() => el.removeChild(container));\n      }\n    },\n    undefined,\n    {\n      render: !hydrating\n    }\n  );\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  const cached = createMemo(() => p.component);\n  return createMemo(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport {\n  Aliases,\n  voidFn as Assets,\n  ChildProperties,\n  DOMElements,\n  DelegatedEvents,\n  Dynamic,\n  Hydration,\n  voidFn as HydrationScript,\n  NoHydration,\n  Portal,\n  Properties,\n  RequestContext,\n  SVGElements,\n  SVGNamespace,\n  addEventListener,\n  assign,\n  classList,\n  className,\n  clearDelegatedEvents,\n  delegateEvents,\n  dynamicProperty,\n  escape,\n  voidFn as generateHydrationScript,\n  voidFn as getAssets,\n  getHydrationKey,\n  getNextElement,\n  getNextMarker,\n  getNextMatch,\n  getPropAlias,\n  voidFn as getRequestEvent,\n  hydrate,\n  innerHTML,\n  insert,\n  isDev,\n  isServer,\n  render,\n  renderToStream,\n  renderToString,\n  renderToStringAsync,\n  resolveSSRNode,\n  runHydrationEvents,\n  setAttribute,\n  setAttributeNS,\n  setProperty,\n  spread,\n  ssr,\n  ssrAttribute,\n  ssrClassList,\n  ssrElement,\n  ssrHydrationKey,\n  ssrSpread,\n  ssrStyle,\n  style,\n  template,\n  use,\n  voidFn as useAssets\n};\n","/*\n * SPDX-FileCopyrightText:  Copyright 2024 Roland Csaszar\n * SPDX-License-Identifier: AGPL-3.0-or-later\n *\n * Project:  Bisectriz\n * File:     zodiacs.ts\n * Date:     30.May.2024\n *\n * =============================================================================\n */\n\n/**\n * The 12 zodiac signs.\n */\nexport const enum Zodiacs {\n    Aries,\n    Taurus,\n    Gemini,\n    Cancer,\n    Leo,\n    Virgo,\n    Libra,\n    Scorpio,\n    Sagittarius,\n    Capricorn,\n    Aquarius,\n    Pisces,\n}\n\n/**\n * Constant to multiply the zodiac index with to get the angle in degrees.\n * Starting with Aries at 0.\n */\nexport const zodiacDegreeFactor = 30;\n\n/**\n * Return the angle in degrees of the given zodiac, starting with aries at 0.\n * @param z The zodiac to get the angle of.\n * @returns The angle in degrees of the given zodiac, starting with aries at 0.\n */\nexport function zodiacDegrees(z: Zodiacs): number {\n    return z * zodiacDegreeFactor;\n}\n\n/**\n * The name of the 12 zodiac sign in slovak.\n */\nexport const zodiacSlovak = [\n    \"baran\",\n    \"bk\",\n    \"blienci\",\n    \"rak\",\n    \"lev\",\n    \"panna\",\n    \"vhy\",\n    \"korpion\",\n    \"strelec\",\n    \"kozoroec\",\n    \"vodnr\",\n    \"ryby\",\n];\n\n/**\n * Return the slovak name of the given zodiac.\n * @param z The zodiac to get the slovak name of.\n * @returns The slovak name of the zodiac.\n */\nexport function zodiacString(z: Zodiacs): string {\n    return zodiacSlovak[z];\n}\n\n/**\n * The Unicode symbols of the 12 zodiac signs.\n */\nconst zodiacSymbols = [\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n];\n\n/**\n * Return the Unicode symbol of the given zodiac.\n * @param z The zodiac to get the symbol of.\n * @returns The Unicode symbol of the zodiac.\n */\nexport function zodiacSymbol(z: Zodiacs): string {\n    return zodiacSymbols[z];\n}\n\n/**\n * A angle given in zodiac signs, degrees and minutes.\n * `z` is angle in as a zodiac sign, the angle in 30 increments,\n * `degrees` is the remainder of the angle in degrees should be between 0 and 30\n *  (exclusive),\n * `minutes` is the remainder of the angle in minutes.\n */\nexport type ZodiacAngle = {\n    // eslint-disable-next-line lines-around-comment\n    /**\n     * The zodiac sign of the angle. This is a angle in 30 increments.\n     */\n    z: Zodiacs;\n\n    /**\n     * The part of the angle in degrees, should be between 0 and 30 (exclusive).\n     */\n    degrees: number;\n\n    /**\n     * The part of the angle in minutes, should be between 0 and 59 (exclusive).\n     * A minute is 1/60 of a degree.\n     */\n    minutes: number;\n};\n\n/**\n * Return a string representation of the given `ZodiacAngle`.\n * @param a The `ZodiacAngle` to convert to a string.\n * @returns The string representation of the given `ZodiacAngle`.\n */\nexport function zodiacAngleString(a: ZodiacAngle): string {\n    return `${zodiacString(a.z)} ${a.degrees}${a.minutes}' ${zodiacSymbol(a.z)}`;\n}\n\n/**\n * Return the angle in degrees of the given `ZodiacAngle`.\n * @param a The `ZodiacAngle` to convert to degrees.\n * @returns The angle in degrees of the given `ZodiacAngle`.\n */\nexport function zodiacAngle2Deg(a: ZodiacAngle): number {\n    // eslint-disable-next-line no-magic-numbers\n    return (a.z * zodiacDegreeFactor + a.degrees + a.minutes / 60) % 360;\n}\n\n/**\n * Return the `ZodiacAngle` of the given angle in degrees.\n * @param angle The angle in degrees to convert to a `ZodiacAngle`.\n * @returns The `ZodiacAngle` of the given angle in degrees.\n */\nexport function deg2ZodiacAngle(angle: number): ZodiacAngle {\n    // eslint-disable-next-line no-magic-numbers\n    const z = Math.floor(angle / zodiacDegreeFactor) % 12;\n    const degrees = Math.floor(angle % zodiacDegreeFactor);\n    // Round two times, once to a factor of ten and then round again after / 10.\n    const minutes = Math.round(\n        // eslint-disable-next-line no-magic-numbers, @typescript-eslint/no-extra-parens\n        Math.round(((angle - (z * zodiacDegreeFactor + degrees)) * 600) % 600) *\n            // eslint-disable-next-line no-magic-numbers\n            0.1,\n    );\n    return { z, degrees, minutes };\n}\n\n/**\n * Return the bisection of the angle between the two given `ZodiacAngle`s.\n * @param a The first `ZodiacAngle` of the angle to bisect.\n * @param b The second `ZodiacAngle` of the angle to bisect.\n * @returns The bisection of the angle between the two given `ZodiacAngle`s.\n */\nexport function bisectZodiacAngle(a: ZodiacAngle, b: ZodiacAngle): ZodiacAngle {\n    const aDeg = zodiacAngle2Deg(a);\n    const bDeg = zodiacAngle2Deg(b);\n    // eslint-disable-next-line no-magic-numbers\n    const cDeg = (aDeg + bDeg) * 0.5;\n    return deg2ZodiacAngle(cDeg);\n}\n","/*\n * SPDX-FileCopyrightText:  Copyright 2024 Roland Csaszar\n * SPDX-License-Identifier: AGPL-3.0-or-later\n *\n * Project:  Bisectriz\n * File:     ZodiacAngleInput.tsx\n * Date:     01.Jun.2024\n *\n * =============================================================================\n * The inputs to let the user set a single `ZodiacAngle` as a component.\n */\n\nimport * as z from \"./zodiacs\";\nimport { Component, Index, Setter } from \"solid-js\";\n\n/**\n * Return the `ZodiacAngleInput` component as JSX.\n * The input fields for the `ZodiacAngle` to are:\n * - zodiac\n * - degrees\n * - minutes\n * @param props The `ZodiacAngle`, its setter function and the id of the\n * `ZodiacAngle` to use for HTML ids.\n * @returns The `ZodiacAngleInput` component as JSX.\n */\n// eslint-disable-next-line func-style\nconst ZodiacAngleInput: Component<{\n    z: z.ZodiacAngle;\n    setZ: Setter<z.ZodiacAngle>;\n    id: number;\n}> = (props) => {\n    // eslint-disable-next-line lines-around-comment\n    /**\n     * Handle the change of the zodiac.\n     * Set the zodiac in the `ZodiacAngle` of the prop.\n     * @param e The event to handle.\n     */\n    function handleZ(e: Event): void {\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (e.currentTarget == null) {\n            return;\n        }\n        const el: HTMLInputElement = e.currentTarget as HTMLInputElement;\n        props.setZ({\n            z: Number(el.value) as z.Zodiacs,\n            degrees: props.z.degrees,\n            minutes: props.z.minutes,\n        });\n    }\n\n    /**\n     * Handle the change of the degrees.\n     * Set the degrees in the `ZodiacAngle` of the prop.\n     * @param e The event to handle.\n     */\n    function handleDeg(e: Event): void {\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (e.currentTarget == null) {\n            return;\n        }\n        const el: HTMLInputElement = e.currentTarget as HTMLInputElement;\n        props.setZ({\n            z: props.z.z,\n            degrees: Number(el.value),\n            minutes: props.z.minutes,\n        });\n    }\n\n    /**\n     * Handle the change of the minutes.\n     * Set the minutes in the `ZodiacAngle` of the prop.\n     * @param e The event to handle.\n     */\n    function handleMin(e: Event): void {\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (e.currentTarget == null) {\n            return;\n        }\n        const el: HTMLInputElement = e.currentTarget as HTMLInputElement;\n        props.setZ({\n            z: props.z.z,\n            degrees: props.z.degrees,\n            minutes: Number(el.value),\n        });\n    }\n\n    return (\n        <>\n            <form\n                class={\n                    (props.id === 1\n                        ? \"border-emerald-200\"\n                        : \"border-emerald-200\") +\n                    \" my-2 rounded-md border-2 border-solid bg-white py-2 text-2xl shadow-md\"\n                }\n                action=\"\"\n                name={\"Zodiac_angle_input\" + props.id}>\n                <label for={\"zodiac\" + props.id}>\n                    <span class=\"sr-only\">\n                        {\"Zodiac sign of the angle \" + props.id}\n                    </span>\n                </label>\n                <select\n                    name={\"zodiac\" + props.id}\n                    id={\"zodiac\" + props.id}\n                    class=\"bg-white font-zodiac\"\n                    onChange={handleZ}>\n                    <Index each={z.zodiacSlovak}>\n                        {(zodiac, i) => (\n                            <option value={i}>\n                                {z.zodiacSymbol(i)} {zodiac()}\n                            </option>\n                        )}\n                    </Index>\n                </select>\n                <label for={\"zodiac\" + props.id + \"-deg\"}>\n                    {\" \"}\n                    <span class=\"sr-only\">\n                        {\"remaining angle in degrees of the angle \" + props.id}\n                    </span>\n                </label>\n                <input\n                    type=\"number\"\n                    name={\"zodiac\" + props.id + \"-deg\"}\n                    id={\"zodiac\" + props.id + \"-deg\"}\n                    class=\"bg-white\"\n                    placeholder=\"0\"\n                    required\n                    min=\"0\"\n                    max=\"29\"\n                    onChange={handleDeg}\n                />\n                \n                <label for={\"zodiac\" + props.id + \"-min\"}>\n                    {\" \"}\n                    <span class=\"sr-only\">\n                        {\"remaining angle in minutes of the angle\" + props.id}\n                    </span>\n                </label>\n                <input\n                    type=\"number\"\n                    name={\"zodiac\" + props.id + \"-min\"}\n                    id={\"zodiac\" + props.id + \"-min\"}\n                    class=\"bg-white\"\n                    placeholder=\"0\"\n                    required\n                    min=\"0\"\n                    max=\"59\"\n                    onChange={handleMin}\n                />\n                '\n            </form>\n        </>\n    );\n};\n\nexport default ZodiacAngleInput;\n","/*\n * SPDX-FileCopyrightText:  Copyright 2024 Roland Csaszar\n * SPDX-License-Identifier: AGPL-3.0-or-later\n *\n * Project:  Bisectriz\n * File:     circle.tsx\n * Date:     04.Jun.2024\n *\n * =============================================================================\n * The component to display the result of bisecting two `ZodiacAngle`s in a\n * drawing.\n */\n\nimport * as z from \"./zodiacs\";\nimport { Component, For, Match, Switch } from \"solid-js\";\n\n/**\n * The `Point` type, a 2D vector with x and y coordinates.\n */\ntype Point = { x: number; y: number };\n\n/**\n * The radius of the outermost circle.\n */\nconst circleRadius = 250;\n\n/**\n * The width of the ring containing the zodiac signs.\n */\nconst ringWidth = 40;\n\n/**\n * The radius of the inner circle of the outer ring containing the zodiac signs.\n */\nconst circleRadiusInner = circleRadius - ringWidth;\n\n/**\n * The center of the circle.\n */\nconst circleCenter: Point = { x: circleRadius + 1, y: circleRadius + 1 };\n\n/**\n * The size of the SVG's view port.\n */\nconst viewPortSize = 2 * circleRadius + 2;\n\n/**\n * The angle between two detail scale lines in degrees.\n */\nconst lineDegree = 5;\n\n/**\n * The number of detail scale lines.\n */\nconst numLines = 360 / lineDegree;\n\n/**\n * The length of the short detail scale lines.\n */\nconst lineLength = 10;\n\n/**\n * The length of the long detail scale lines, which are shown every 10 degrees.\n */\nconst lineLength10 = 15;\n\n/**\n * The offset in degrees of the first zodiac sign - aries. Counterclockwise from\n * \"12 o'clock\".\n */\nconst startOffset = 90;\n\n/**\n * The midpoint of the first zodiac sign - aries.\n * It counterclockwise after \"12 o'clock\" by `z.zodiacDegreeFactor / 2` degrees.\n */\nconst signStartPoint = rotateAroundCenter(\n    { x: circleCenter.x, y: ringWidth / 2 },\n    circleCenter,\n    z.zodiacDegreeFactor / 2,\n);\n\n/**\n * Rotate the `Point` `p` around the `Point` `center` by `angle` degrees.\n * @param p The `Point` to rotate around the given `center`.\n * @param center The center of the rotation.\n * @param angle The angle in degrees to rotate.\n * @returns The point `p` rotated by `angle` degrees around `center`.\n */\nfunction rotateAroundCenter(p: Point, center: Point, angle: number): Point {\n    const tP = {\n        x: p.x - center.x,\n        y: p.y - center.y,\n    };\n    // eslint-disable-next-line @typescript-eslint/no-extra-parens\n    const rad = (angle / 180.0) * Math.PI;\n    const rotTP = {\n        x: tP.x * Math.cos(rad) + tP.y * Math.sin(rad),\n        y: -tP.x * Math.sin(rad) + tP.y * Math.cos(rad),\n    };\n    return {\n        x: rotTP.x + center.x,\n        y: rotTP.y + center.y,\n    };\n}\n\n/**\n * Return the `Circle` component, which is a drawing of a circle of zodiacs, the\n * two given angels and the bisection of the two angles, as JSX.\n * @param props The props holding the two angles and the bisection of the two in\n *              degrees.\n * @returns The `Circle` component as JSX.\n */\n// eslint-disable-next-line func-style\nconst Circle: Component<{\n    z1: number;\n    z2: number;\n    res: number;\n}> = (props) => (\n    <svg viewBox={0 + \" \" + 0 + \" \" + viewPortSize + \" \" + viewPortSize}>\n        <g class=\"fill-none stroke-black stroke-2\" id=\"circles_with_signs\">\n            <circle\n                cx={circleCenter.x}\n                cy={circleCenter.y}\n                r={circleRadius}\n                id=\"outer\"\n            />\n            <circle\n                cx={circleCenter.x}\n                cy={circleCenter.y}\n                r={circleRadiusInner}\n                id=\"inner2\"\n            />\n\n            <For each={Array.from({ length: 12 })}>\n                {(_, i) => (\n                    <>\n                        <g\n                            transform={\n                                \"rotate(\" +\n                                i() * z.zodiacDegreeFactor +\n                                \",\" +\n                                circleCenter.x +\n                                \",\" +\n                                circleCenter.y +\n                                \")\"\n                            }>\n                            <line\n                                x1={circleCenter.x}\n                                y1={0}\n                                x2={circleCenter.x}\n                                y2={ringWidth}\n                            />\n                        </g>\n                        <text\n                            text-anchor=\"middle\"\n                            dominant-baseline=\"central\"\n                            class=\"font-zodiac text-2xl\"\n                            {...(rotateAroundCenter(\n                                signStartPoint,\n                                circleCenter,\n                                i() * z.zodiacDegreeFactor + startOffset,\n                            ) as Object)}>\n                            {z.zodiacSymbol(i())}\n                        </text>\n                    </>\n                )}\n            </For>\n            <For each={Array.from({ length: numLines })}>\n                {(_, i) => (\n                    <>\n                        <g\n                            transform={\n                                \"rotate(\" +\n                                i() * lineDegree +\n                                \",\" +\n                                circleCenter.x +\n                                \",\" +\n                                circleCenter.y +\n                                \")\"\n                            }>\n                            <Switch>\n                                <Match when={(i() * lineDegree) % 10 === 0}>\n                                    <line\n                                        x1={circleCenter.x}\n                                        y1={ringWidth}\n                                        x2={circleCenter.x}\n                                        y2={ringWidth + lineLength10}\n                                    />\n                                </Match>\n                                <Match when={(i() * lineDegree) % 10 !== 0}>\n                                    <line\n                                        x1={circleCenter.x}\n                                        y1={ringWidth}\n                                        x2={circleCenter.x}\n                                        y2={ringWidth + lineLength}\n                                        stroke-width={1}\n                                    />\n                                </Match>\n                            </Switch>\n                        </g>\n                    </>\n                )}\n            </For>\n        </g>\n        <g stroke-width=\"5\" id=\"angles\">\n            <g\n                transform={\n                    \"rotate(\" +\n                    -((props.z1 + startOffset) % 360) +\n                    \",\" +\n                    circleCenter.x +\n                    \",\" +\n                    circleCenter.y +\n                    \")\"\n                }\n                class=\"fill-none stroke-emerald-200\"\n                id=\"angle1\">\n                <line\n                    x1={circleCenter.x}\n                    y1={ringWidth}\n                    x2={circleCenter.x}\n                    y2={circleCenter.y}\n                />\n            </g>\n            <g\n                transform={\n                    \"rotate(\" +\n                    -((props.z2 + startOffset) % 360) +\n                    \",\" +\n                    circleCenter.x +\n                    \",\" +\n                    circleCenter.y +\n                    \")\"\n                }\n                class=\"fill-none stroke-emerald-200\"\n                id=\"angle2\">\n                <line\n                    x1={circleCenter.x}\n                    y1={ringWidth}\n                    x2={circleCenter.x}\n                    y2={circleCenter.y}\n                />\n            </g>\n            <g\n                transform={\n                    \"rotate(\" +\n                    -((props.res + startOffset) % 360) +\n                    \",\" +\n                    circleCenter.x +\n                    \",\" +\n                    circleCenter.y +\n                    \")\"\n                }\n                class=\"fill-none stroke-red-700\"\n                id=\"bisect_angle\">\n                <line\n                    x1={circleCenter.x}\n                    y1={ringWidth}\n                    x2={circleCenter.x}\n                    y2={circleCenter.y}\n                />\n            </g>\n        </g>\n        <circle\n            cx={circleCenter.x}\n            cy={circleCenter.y}\n            r={5}\n            class=\"fill-white stroke-black stroke-2\"\n            id=\"centerPoint\"\n        />\n    </svg>\n);\n\nexport default Circle;\n","/*\n * SPDX-FileCopyrightText:  Copyright 2024 Roland Csaszar\n * SPDX-License-Identifier: AGPL-3.0-or-later\n *\n * Project:  Bisectriz\n * File:     ZodiacAnglesDisplay.tsx\n * Date:     01.Jun.2024\n *\n * =============================================================================\n * The component to display the result of bisecting two `ZodiacAngle`s.\n */\n\nimport * as z from \"./zodiacs\";\nimport Circle from \"./circle\";\nimport { Component } from \"solid-js\";\n\n/**\n * Return the `ZodiacAnglesDisplay` component as JSX.\n * Contains the text display of the bisect of two `ZodiacAngle`s and the circle\n * of zodiacs displaying the two `ZodiacAngle`s as two lines and the bisect\n * angle of these.\n * @param props The two `ZodiacAngle`s to display.\n * @returns The `ZodiacAnglesDisplay` component as JSX.\n */\n// eslint-disable-next-line func-style\nconst ZodiacAnglesDisplay: Component<{\n    z1: z.ZodiacAngle;\n    z2: z.ZodiacAngle;\n}> = (props) => (\n    <>\n        <p\n            class=\"my-2 flex flex-wrap justify-center rounded-md border-2 border-solid border-red-700 bg-gray-100 py-2 font-zodiac text-2xl\"\n            id=\"result_bisect\">\n            <span class=\"px-1\">Bisectriz:</span>\n            <span class=\"px-1\">\n                {z.zodiacAngleString(z.bisectZodiacAngle(props.z1, props.z2))}\n            </span>\n        </p>\n        <div id=\"result_circle\">\n            <Circle\n                z1={z.zodiacAngle2Deg(props.z1)}\n                z2={z.zodiacAngle2Deg(props.z2)}\n                res={z.zodiacAngle2Deg(z.bisectZodiacAngle(props.z1, props.z2))}\n            />\n        </div>\n    </>\n);\n\nexport default ZodiacAnglesDisplay;\n","/*\n * SPDX-FileCopyrightText:  Copyright 2024 Roland Csaszar\n * SPDX-License-Identifier: AGPL-3.0-or-later\n *\n * Project:  Bisectriz\n * File:     App.tsx\n * Date:     30.May.2024\n *\n * ==============================================================================\n * The main app component.\n */\n\nimport * as z from \"./zodiacs\";\nimport { Accessor, JSX, Setter, createSignal } from \"solid-js\";\nimport ZodiacAngleInput from \"./ZodiacAngleInput\";\nimport ZodiacAnglesDisplay from \"./ZodiacAnglesDisplay\";\n\n/**\n * The app's main component.\n * @returns {JSX.Element} Main app component.\n */\n// eslint-disable-next-line max-lines-per-function\nfunction App(): JSX.Element {\n    const [z1, setZ1]: [Accessor<z.ZodiacAngle>, Setter<z.ZodiacAngle>] =\n        createSignal({\n            z: z.Zodiacs.Aries as z.Zodiacs,\n            degrees: 0,\n            minutes: 0,\n        });\n    const [z2, setZ2]: [Accessor<z.ZodiacAngle>, Setter<z.ZodiacAngle>] =\n        createSignal({\n            z: z.Zodiacs.Aries as z.Zodiacs,\n            degrees: 0,\n            minutes: 0,\n        });\n\n    return (\n        <>\n            <section>\n                <ZodiacAngleInput z={z1()} setZ={setZ1} id={1} />\n                <ZodiacAngleInput z={z2()} setZ={setZ2} id={2} />\n            </section>\n            <section>\n                <ZodiacAnglesDisplay z1={z1()} z2={z2()} />\n            </section>\n        </>\n    );\n}\n\nexport default App;\n","/*\n * SPDX-FileCopyrightText:  Copyright 2024 Roland Csaszar\n * SPDX-License-Identifier: AGPL-3.0-or-later\n *\n * Project:  Bisectriz\n * File:     index.tsx\n * Date:     01.Jun.2024\n *\n * ==============================================================================\n * The entry point of the web app.\n */\n\n/* @refresh reload */\nimport \"./index.css\";\nimport App from \"./App\";\nimport { render } from \"solid-js/web\";\n\nconst root = document.getElementById(\"app\");\n\nrender(() => <App />, root!);\n"],"names":["equalFn","a","b","$PROXY","$TRACK","signalOptions","runEffects","runQueue","STALE","PENDING","UNOWNED","Owner","Transition","ExternalSourceConfig","Listener","Updates","Effects","ExecCount","createRoot","fn","detachedOwner","listener","owner","unowned","current","root","updateFn","untrack","cleanNode","runUpdates","createSignal","value","options","s","setter","writeSignal","readSignal","createRenderEffect","c","createComputation","updateComputation","createMemo","onCleanup","children","memo","resolveChildren","updates","lookUpstream","sSlot","node","isComp","i","o","TransitionRunning","markDownstream","time","runComputation","nextValue","err","handleError","init","pure","state","runTop","ancestors","wait","res","completeUpdates","e","queue","ignore","source","index","obs","n","castError","results","result","FALLBACK","dispose","d","mapArray","list","mapFn","items","mapped","disposers","len","indexes","newItems","j","newLen","newIndices","newIndicesNext","temp","tempdisposers","tempIndexes","start","end","newEnd","item","disposer","mapper","set","indexArray","signals","hydrationEnabled","createComponent","Comp","props","trueFn","propTraps","_","property","receiver","resolveSource","resolveSources","length","v","mergeProps","sources","proxy","keys","sourcesMap","defined","sourceKeys","key","desc","target","definedKeys","narrowedError","name","For","fallback","Index","Switch","keyed","equals","conditions","evalConditions","conds","when","cond","Match","ChildProperties","Aliases","DelegatedEvents","SVGNamespace","reconcileArrays","parentNode","bLength","aEnd","bEnd","aStart","bStart","after","map","sequence","t","$$EVENTS","render","code","element","insert","template","html","isCE","isSVG","create","delegateEvents","eventNames","document","l","eventHandler","setAttribute","setAttributeNS","namespace","className","addEventListener","handler","delegate","handlerFn","classList","prev","classKeys","prevKeys","toggleClassKey","classValue","style","nodeStyle","spread","skipChildren","prevProps","use","assign","arg","parent","accessor","marker","initial","insertExpression","skipRef","prop","assignProp","toPropertyName","w","classNames","nameLen","isProp","isChildProp","forceProp","h","ns","data","unwrapArray","multi","cleanChildren","array","currentArray","normalizeIncomingArray","appendNodes","normalized","unwrap","dynamic","replacement","inserted","el","isParent","Zodiacs","Zodiacs2","zodiacDegreeFactor","zodiacSlovak","zodiacString","z","zodiacSymbols","zodiacSymbol","zodiacAngleString","zodiacAngle2Deg","deg2ZodiacAngle","angle","degrees","minutes","bisectZodiacAngle","aDeg","bDeg","cDeg","ZodiacAngleInput","handleZ","currentTarget","setZ","Number","handleDeg","handleMin","_el$","_tmpl$","_el$2","firstChild","_el$3","_el$4","nextSibling","_el$5","_el$6","_el$7","_el$8","_el$9","_el$10","_el$11","_el$12","_el$13","_$insert","id","_$createComponent","each","zodiac","_el$14","_tmpl$2","_el$15","_$effect","_p$","_v$","_v$2","_v$3","_v$4","_v$5","_v$6","_v$7","_v$8","_v$9","_v$10","_v$11","_$className","_$setAttribute","r","undefined","circleRadius","ringWidth","circleCenter","x","y","lineDegree","numLines","startOffset","signStartPoint","rotateAroundCenter","p","center","tP","rad","Math","PI","rotTP","cos","sin","Circle","Array","from","_v$19","_v$20","_v$21","_tmpl$3","_$spread","_$mergeProps","_el$16","_tmpl$6","_el$17","_tmpl$4","_v$22","_v$23","_el$18","_tmpl$5","_v$24","_v$25","z1","z2","_v$12","_v$13","_v$14","_v$15","_v$16","_v$17","_v$18","u","m","f","g","ZodiacAnglesDisplay","App","setZ1","Aries","setZ2","getElementById"],"mappings":"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","x_google_ignoreList":[1,2]}